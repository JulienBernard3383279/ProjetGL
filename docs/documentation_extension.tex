\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\RequirePackage[utf8]{inputenc}

\begin{document}
\title{Compilateur Deca : Documentation de l'extension : Optimisation}
\author{\'Equipe 58}
\maketitle
\section{Introduction}
Pour notre compilateur Decac nous avons dû choisir une extension parmis plusieurs extension, et notre choix s'est porté sur l'optimisation. L'optimisation consiste à rendre un code plus performant, c'est à dire à l'exécuter plus rapidement en faisant moins d'opérations au niveau du processeur, ou des opérations qui sont plus rapides.
\section{Spécification de l'extension Optimisation}
\subsection{Optimisations implémentées}
Voici la liste des différentes spécifications de l'optimisation:
\begin{itemize}
\item \texttt{Dead Store} \\
      \texttt{decac -o1} \\
Le dead store consiste à éliminer les variables qui ne sont pas utiles dans le code.
\item \texttt{Constant Folding}\\
\texttt{decac -o2}\\
Le constant folding est une optimisation qui calcul tout les calculs constants et stocke les résultats au lieu de stocker le calcul. A l'exécution le processeur n'a plus besoin de faire les opérations, il à déjà le résultat en mémoire.
     \end{itemize}
\subsection{Optimisations envisagées}
\begin{itemize}
\item \texttt{Inlining} \\
Le inlining est une optimisation qui consiste à remplacer les appels des méthodes par le corps des méthodes, dans le cas ou la méthode ne prend pas trop de place en mémoire. Ceci permet de gagner du temps car la méthode n'est pas appelée lors de l'exécution, mais cette optimisation ne peut pas être utilisé sur les méthodes qui prendraient trop de place en mémoire.
\item \texttt{Strengh Reduction} \\
Le strengh reduction est une optimisation qui remplace certaines opérations par d'autres qui sont équivalentes. Une multiplication peut être remplacé par une succession d'addition, une multiplication par une puissance de 2 peut être remplacé par un décalage à gauche. Il y a de multiples façons de faire des strengh reductions qui améliore localement l'optimalité du code.
\item \texttt{Common Subexpression} \\
Le common subexpression est une optimisation qui consiste à ne calculer qu'une seule fois les sous expressions qui apparaissent à plusieurs endroits dans le code, de manière à les stocker pour ne plus les recalculer ensuite. Lorsque le calcul réapparaît dans le programme le processeur a juste besoin de charger la valeur stockée et n'a pas besoin de refaire le calcul.
\item \texttt{Optimiastion des registres au niveau du processeur} \\
Cette optimisation consiste à regarder dans le code généré en assembleur s'il y a des améliorations possibles. Dans certains cas le processeur fait un calcul sur une variable puis la stocke, mais la recharge juste après pour la réutiliser. On gagne en rapidité si on supprime tous les stockages et les chargements inutiles de variables dans le processeur. 
     \end{itemize}
\section{Analyse bibliographique}
\subsection{Liens sur l'optimisation de la compilation en Java}
\item \texttt{http://www.javaworld.com/article/2078623/core-java/jvm-performance-optimization-part-1-a-jvm-technology-primer.html} \\
Ce lien donne des informations générales sur la compilation en Java en donnant quelques concepts généraux sur l'optimisation du Java et du Bytecode Java.
\item \texttt{http://www.javaworld.com/article/2078635/enterprise-middleware/jvm-performance-optimization-part-2-compilers.html} \\

\item \texttt{} \\
\item \texttt{} \\
\item \texttt{} \\
     \end{itemize}
\section{Choix de conception}
\section{Méthode de validation}
\section{Résultat}
\section{Améliorations possibles de l'extension}

\end{document}
